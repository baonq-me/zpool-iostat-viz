#!/usr/bin/env python3

#
# Copyright (c) 2021, Chad Miller  chad.org
# All rights reserved.
#

import sys
import curses
import subprocess
from collections import namedtuple
from contextlib import suppress
import base64
import argparse


ColsIoStat = namedtuple("ColsIoStat", "latency_nsec total_wait_read total_wait_write disk_wait_read disk_wait_write syncq_wait_read syncq_wait_write asyncq_wait_read asyncq_wait_write scrub trim")
ColsIoStat.__new__.__defaults__ = tuple(0 for x in ColsIoStat._fields)

EMPTY_COLOR = 239
EMPTY_CHAR = "|"
PALETTES = list(range(start, end+(second-start), second-start) for second, start, end in ((63, 27, 207), (87, 51, 231), (116, 123, 88), (220, 226, 196), (224, 231, 196), (80, 51, 196), (77, 40, 225), (225, 231, 201), (243, 240, 255), (227, 226, 231), (27, 21, 51)))
DISPLAY_CHARS = ".abcdefghijklmnopqrstuvwxyz^"

raw = None

def short_time_and_color(ns):
    """Given a time in nanoseconds, return a pleasant, legible string
    approximating that time, and an integer representing an appropriate color for
    that number of nanoseconds of waiting. Bigger is worse."""
    ## These timing colors are stupid and overly-opinionated. Please advise.
    if ns < 30000:
        color = TIME_ANSI_COLORS[0]
    elif ns < 600000:
        color = TIME_ANSI_COLORS[1]
    elif ns < 8500000:
        color = TIME_ANSI_COLORS[2]
    elif ns < 15000000:
        color = TIME_ANSI_COLORS[3]
    elif ns < 155000000:
        color = TIME_ANSI_COLORS[4]
    else:
        color = TIME_ANSI_COLORS[5]

    if ns < 800000:
        return "{: 7.2f}µs".format(ns/1000), color
    elif ns < 1000000000:
        return "{: 7.2f}ms".format(ns/1000/1000), color
    else:
        return "{: 7.2f}s".format(ns/1000/1000/1000), color


def get_stats(pool_names, filename=None):
    """Populate a "raw" global variable of the last thing we read, and return a
    structure -- a list of pairs of vdev-name and vdev-timings, where a vdev-timing
    is a list of rows, each as a ColsIoStat named tuple."""
    global raw
    if filename:
        with open(filename, encoding="UTF-8") as f:
            raw = f.read()
    else:
        zpool_cmd = subprocess.run(["zpool", "iostat", "-wvHp", "--"] + (pool_names if pool_names else []), check=True, stdout=subprocess.PIPE, encoding="UTF-8")
        raw = zpool_cmd.stdout
    stats = []
    for line in raw.split("\n"):
        if not line:
            continue
        elif "\t" in line:
            row_number += 1
            stats[-1][1].append(ColsIoStat(*tuple(int(s) for s in line.split("\t"))))
        else:
            row_number = -1
            stats.append([line, []])

    return stats


def scaled_to_fraction(range_minimum, subject_value, range_maximum):
    """Take a number in a range and return a fraction of how far it is into
    that range."""
    if range_minimum == range_maximum:
        return 0
    assert range_minimum <= subject_value <= range_maximum, (range_minimum, subject_value, range_maximum)
    return (subject_value-range_minimum) / (range_maximum-range_minimum)


def actual_display_at_location(window, column_offset, title, table, lenstats, current, movchr1, movchr2):
    """Render a narrow table at a specified distance from the left. Useful to
    have parallel renderings of what's happening with a level of organization in a
    pool."""
    column_width = 2

    maxes = [max(r) for r in zip(*table)]
    try:
        mins = [min(v for v in r if v != m/100) for r, m in zip(zip(*table), maxes)]
    except ValueError:
        mins = [0 for x in maxes]

    rows_containing_data = list()
    for row_number, row in enumerate(table):
        for column_number, val in enumerate(row[1:]):
            if val > 0:
                rows_containing_data.append(row_number)

    with suppress(curses.error):
        window.addstr(0, column_offset-8, "{}/{} {} {}  dev {!r}".format(current+1, lenstats, movchr1, movchr2, title))
    printed_row_number = 0
    for row_number, row in enumerate(table):
        if not rows_containing_data or not min(rows_containing_data)-1 <= row_number <= max(rows_containing_data)+1: continue
        printed_row_number += 1
        with suppress(curses.error):
            t, col = short_time_and_color(row[0])
            window.addstr(printed_row_number, column_offset-8, t, curses.color_pair(col)) # write legend
        for column_number, val in enumerate(row):
            if column_number == 0: continue  # skip legend
            if val > maxes[column_number]//1000:  # don't show one-offs
                scaled_0_to_1 = scaled_to_fraction(mins[column_number], val, maxes[column_number])
                glyph = DISPLAY_CHARS[int(scaled_0_to_1 * (len(DISPLAY_CHARS)-1))]
                color = HISTOGRAM_ANSI_COLORS[int(scaled_0_to_1 * (len(HISTOGRAM_ANSI_COLORS)-1))]
                with suppress(curses.error):
                    window.addstr(printed_row_number, column_offset+(column_number*column_width), glyph, curses.color_pair(color))
            else:
                with suppress(curses.error):
                    window.addstr(printed_row_number, column_offset+(column_number*column_width), EMPTY_CHAR, curses.color_pair(EMPTY_COLOR))

    if rows_containing_data:
        stat_names = list(reversed(list(table[0]._fields[1:])))
        with suppress(curses.error):
            window.addstr(printed_row_number+3, column_offset+2-len("stats  "), "stats")
        while stat_names:
            printed_row_number += 1
            stat_name = stat_names.pop(0)
            with suppress(curses.error):
                window.addstr(printed_row_number, column_offset+2, "{}`{}".format("| " * len(stat_names), stat_name))
    else:
        with suppress(curses.error):
            window.addstr(4, 16, "(no data)")


def display_measurements_for_device(pool, filename, window):
    """Display all information about a vdev in a table."""
    stats = get_stats(pool, filename)

    current1 = 0
    current2 = -1
    while True:
        window.clear()

        title, data = stats[current1]
        actual_display_at_location(window, 12, title, data, len(stats), current1, "←", "→")

        #if window.getmaxyx()[1] > 90:
        #    title, data = stats[current2]
        #    actual_display_at_location(window, 60, title, data, len(stats), current2, "↓", "↑")

        height, width = window.getmaxyx()
        message = "  Population of column's histogram buckets shown with .a-z^ and colors"
        with suppress(curses.error):
            window.addstr(height-1, width-len(message)-1, message)
            for i, (ch, color) in enumerate(zip(reversed(message), reversed(HISTOGRAM_ANSI_COLORS))):
                window.addstr(height-1, width-1-i-1, ch, curses.color_pair(color))

        window.refresh()

        in_key = window.getch()
        if in_key == -1:
            pass
        elif in_key == curses.KEY_RIGHT:
            current1 += 1
        elif in_key == curses.KEY_LEFT:
            current1 -= 1
        elif in_key == curses.KEY_UP:
            current2 += 1
        elif in_key == curses.KEY_DOWN:
            current2 -= 1
        elif in_key == ord('q') or in_key == ord('x') or in_key == 27:
            return
        current1 += len(stats)
        current1 %= len(stats)
        current2 += len(stats)
        current2 %= len(stats)

        stats = get_stats(pool, filename)


def display_devices_for_measurement(pool, filename, window):
    """Display all devices for a given measurement. Emphasize comparison of devices."""
    stats = get_stats(pool, filename)

    current = 0
    while True:
        window.clear()

        column_max = tuple(max(row[current+1] for row in device_data) for device_name, device_data in stats)

        rows_containing_data = set()
        for row_number, row in enumerate(stats[0][1]):
            for device_number, (device_name, device_data) in enumerate(stats):
                scaled_0_to_1 = scaled_to_fraction(0, device_data[row_number][current+1], column_max[device_number])
                if scaled_0_to_1 > 0.001:
                    rows_containing_data.add(row_number)

        with suppress(curses.error):
            window.addstr(0, 1, "{}/{} ← →   Statistic {!r}".format(current+1, len(stats[0][1][0])-1, stats[0][1][0]._fields[current+1]))
        # Assume all histogram buckets are the same
        printed_row_number = 0
        for row_number, row in enumerate(stats[0][1]):
            if not rows_containing_data or not min(rows_containing_data)-1 <= row_number <= max(rows_containing_data)+1: continue
            printed_row_number += 1
            with suppress(curses.error):
                t, col = short_time_and_color(row[0])
                window.addstr(printed_row_number, 0, t, curses.color_pair(col))  # write legend
            for device_number, (device_name, device_data) in enumerate(stats):
                scaled_0_to_1 = scaled_to_fraction(0, device_data[row_number][current+1], column_max[device_number])
                glyph = DISPLAY_CHARS[int(scaled_0_to_1 * (len(DISPLAY_CHARS)-1))]
                color = HISTOGRAM_ANSI_COLORS[int(scaled_0_to_1 * (len(HISTOGRAM_ANSI_COLORS)-1))]
                if scaled_0_to_1 > 0.001:
                    with suppress(curses.error):
                        window.addstr(printed_row_number, 12+(device_number*2), glyph, curses.color_pair(color))
                else:
                    with suppress(curses.error):
                        window.addstr(printed_row_number, 12+(device_number*2), EMPTY_CHAR, curses.color_pair(EMPTY_COLOR))

        if rows_containing_data:
            device_names = list(reversed(list(device_name for device_name, device_data in stats)))
            with suppress(curses.error):
                window.addstr(printed_row_number+3, 12-len("devs  "), "devs")
            while device_names:
                printed_row_number += 1
                device_name = device_names.pop(0)
                with suppress(curses.error):
                    window.addstr(printed_row_number, 12, "{}`{}".format("| " * len(device_names), device_name))
        else:
            with suppress(curses.error):
                window.addstr(4, 16, "(no data)")

        height, width = window.getmaxyx()
        message = "  Population of histogram buckets shown with .a-z^ and colors"
        with suppress(curses.error):
            window.addstr(height-1, width-len(message)-1, message)
            for i, (ch, color) in enumerate(zip(reversed(message), reversed(HISTOGRAM_ANSI_COLORS))):
                window.addstr(height-1, width-1-i-1, ch, curses.color_pair(color))

        window.refresh()

        in_key = window.getch()
        if in_key == -1:
            pass
        elif in_key == curses.KEY_RIGHT:
            current += 1
        elif in_key == curses.KEY_LEFT:
            current -= 1
        elif in_key == ord('q') or in_key == ord('x') or in_key == 27:
            return
        current += len(stats[0][1][0])-1
        current %= len(stats[0][1][0])-1

        stats = get_stats(pool, filename)


def main(window, pool, filename, views):
    window.timeout(1000)

    curses.use_default_colors()
    curses.curs_set(0)
    for i in range(0, curses.COLORS):
        curses.init_pair(i, i, -1)

    for view in views:
        if view == "d": display_measurements_for_device(pool, filename, window)
        if view == "s": display_devices_for_measurement(pool, filename, window)


if __name__ == "__main__":
    try:
        arg_parser = argparse.ArgumentParser("zpool-iostat-viz", description="Display ZFS pool statistics, by device and by measurement")

        arg_parser.add_argument("-b", "--by", dest="by", action="store", default="s", help="slice data by [d]evice or [s]tat (s)")
        arg_parser.add_argument("-f", "--from-file", dest="file", action="store")
        arg_parser.add_argument("--pal-time", "--pt", action="store", metavar="P", default="3", help="palette for time buckets")
        arg_parser.add_argument("--pal-count", "--pc", action="store", metavar="P", default="0", help="palette for bucket populations")
        arg_parser.add_argument("parts", metavar="pool/vdev", nargs="*", help="Pools or vdevs to display")
        arg_parser.add_argument("--help-colors", action="store_true", help="see color palettes available")

        parsed_args = vars(arg_parser.parse_args())

        help_see_colors = parsed_args["help_colors"]
        try:
            HISTOGRAM_ANSI_COLORS = PALETTES[int(parsed_args["pal_count"], 16)]
            TIME_ANSI_COLORS = PALETTES[int(parsed_args["pal_time"], 16)]
        except (IndexError, ValueError):
            help_see_colors = True

        if help_see_colors:
            print("color palettes (P) for use with --pal-time P or --pal-count P")
            for i, palette in enumerate(PALETTES):
                rainbow = ["\033[38;5;{0}m {0:03d}\033[m".format(color, i) for color in palette]
                print("   {0:x}   {1}".format(i, "".join(rainbow)), end="")
                if hex(i)[2:] == parsed_args["pal_count"]: print("  (count)", end="")
                if hex(i)[2:] == parsed_args["pal_time"]: print("  (time)", end="")
                print()
            sys.exit(0)

        curses.wrapper(lambda window: main(window, parsed_args["parts"], parsed_args["file"], parsed_args["by"] or "s"))
    except subprocess.CalledProcessError as exc:
        print("I couldn't get your pool information. Make sure you have 'zpool' program and specify your pool correctly.")
        print(exc)
    except Exception as exc:
        print("CRASH! Sorry!")
        print("Please report this error at \nhttps://github.com/chadmiller/zpool-iostat-viz/issues/new")
        print()
        print("Paste the following:")
        if raw is not None:
            print(base64.encodebytes(raw.encode("UTF-8")).decode("ASCII"), end="and also include ")
        raise exc
